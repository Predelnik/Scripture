import re

def write_name_cleanup (fp, name): # cleanup all possible name usages
	# used for linear address (variable/func)
	# TODO: make it function in ids instead of generating ton of code
	fp.write ('addr = get_name_ea_simple ("{}");\n'.format (name))
	fp.write ('if (addr != BADADDR) set_name (addr, "");\n')
	# used for custom data type (local types)
	fp.write ('id = find_custom_data_type("{}");\n'.format (name))
	fp.write ('if (id != -1) set_local_type (-1, "", 0);\n'.format (name))
	# used for struct name
	fp.write ('id = get_struc_id ("{}");\n'.format (name))
	fp.write ('if (id != -1) del_struc(id);\n')
	# used for enum name
	fp.write ('id = get_enum ("{}");\n'.format (name))
	fp.write ('if (id != -1) del_enum(id);\n')

# data is dict specified by extract.py (unstable)
def write_header (fp):
	fp.write ('// Generated by Scripture (https://github.com/predelnik/scripture)\n')
	fp.write ("// Warning: script will aggressively change name of the functions and redefine structs if there's name collision. Use with care.\n")
	fp.write ('\n')
	fp.write ('#include <idc.idc>\n')
	fp.write ('static main() {\n')
	fp.write ('auto id = -1;\n')
	fp.write ('auto addr = -1;\n')
	for bits in ['8', '16', '32']:
		for prefix in [('u', 'unsigned '), ('', '')]:
			for body in ['int', 'bool']:
				if body == 'bool' and prefix[0] == 'u':
					continue
				source_type = '{}{}{}_t'.format (prefix[0], body, bits)
				dest_type = '{} __int{}'.format (prefix[1], bits)
				write_name_cleanup (fp, source_type)
				fp.write ('set_local_type (-1, "typedef {} {}", 0);\n'.format (dest_type, source_type))

def check_flags (flags, size, extent, struct_name, member):
	if size > 0:
		member_size = int(member['size'])
		if member_size != extent * size:
			print ('Possible error with member {} of struct {}. member size({}) != extent({}) * size({})'.
				format (member['name'], struct_name, member_size, extent, size))
	if size == 1:
		flags.append ('FF_BYTE')
	elif size == 2:
		flags.append ('FF_WORD')
	elif size == 4:
		flags.append ('FF_DWORD')
	return flags

def member_flags_id(data, struct_name, member):
	type = member['type']
	size = int (member['size'])
	if re.match (r'([a-zA-z]*)\s*\(\*\)\((?:([a-zA-z\*]*),\s*)*([a-zA-z\*]*)?\)', type):
		return check_flags (['FF_0OFF'], 4, 1, struct_name, member), -1
	m = re.match (r'([a-zA-z0-9_\*]*(?:\s*\*)?)\s*(?:\[(.*)\])*', type)
	if not m:
		return
	type = m.group(1).strip ()
	extent = int(m.group(2)) if m.group(2) else 1
	if type.endswith ('*') and type[:-1].strip () in data['structs']:
		return check_flags (['FF_0STRO'], 4, extent, struct_name, member), 'get_struc_id ("{}")'.format (type[:-1].strip ())
	if type in data['structs']:
		if 'size' in data['structs'][type]:
			struct_size = int (data['structs'][type]['size'])
			member_size = int(member['size'])
			if member_size != extent * struct_size:
				print ('Possible error with member {} of struct {}. member size({}) != extent({}) * size({})'.format (member['name'], struct_name, member_size, extent, struct_size))
		return ['FF_STRUCT'], 'get_struc_id ("{}")'.format (type)
	if type in data['enums']:
		return check_flags(['FF_0ENUM'], size, extent, struct_name, member), 'get_enum ("{}")'.format (type)

	if type in ['int8_t', 'uint8_t', 'bool8_t', 'BYTE', 'char', 'unsigned char']:
		return check_flags([], 1, extent, struct_name, member), -1
	if type in ['int16_t', 'uint16_t', 'bool16_t', 'WORD']:
		return check_flags([], 2, extent, struct_name, member), -1
	if type in ['int', 'int32_t', 'uint32_t', 'bool32_t', 'DWORD', 'uint', 'bool']:
		return check_flags([], 4, extent, struct_name, member), -1
	return check_flags (['FF_0OFF'], 4, extent, struct_name, member), -1

def stringify (str):
	return '"{}"'.format (str.replace ('\n', '\\n').replace ('\r', '\\r').replace ('"', '\\"'))

def write_struct (data, name, struct_data, fp):
	fp.write ('{\n')
	write_name_cleanup (fp, name)
	if not 'offset' in struct_data['members'][0]:
		fp.write ('parse_decls ({}, 0);\n'.format (stringify (struct_data['text'])))
	else:
		fp.write ('id = add_struc(-1, "{}", 0);\n'.format (name))
		for member in struct_data['members']:
			flags, id = member_flags_id (data, name, member)
			size = 0
			fp.write ('add_struc_member (id, "{}", 0x{}, FF_DATA | {}, {}, {});\n'.format (member['name'], member['offset'], ' | '.join (flags), id, member['size']))
			# Set type is bad for enums because by our definition they may have various width in different structures but IDA will reset size to 4 in this case
			# But SetType does nothing for such members anyway
			if not 'FF_0ENUM' in flags:
				fp.write ('SetType (get_member_id (id, 0x{}), "{}");\n'.format (member['offset'], member['type'])) # non-trivial command but ida itself does it (in generated IDC)
	fp.write ('import_type(-1, "{}");'.format (name))
	fp.write ('}\n')

def write_structs (data, fp):
	for file_name in ['sha1.h', 'windows.h', 'structs.h']: # it's hard to determine correct order here in general case
		for name, struct_data in sorted(list (data['structs'].items()), key=lambda t: t[1]['line']):
			if struct_data['full_file_name'] != file_name:
				continue
			write_struct (data, name, struct_data, fp)

def write_enums (data, fp):
	for name, enum_data in sorted(list (data['enums'].items()), key=lambda t: t[1]['line']):
		# Removing previously defined struct to avoid collision
		write_name_cleanup (fp, name)
		# it's yet unclear how to make enum signed, but looks like in IDA 7.0 it doesn't affect anything anyway
		fp.write ('id = add_enum (-1, "{}", {});\n'.format (name, 'FF_0NUMH' if 'bitflag' in enum_data else 'FF_0NUMD'))
		for member in enum_data['members']:
			fp.write ('add_enum_member (id, "{}", {}, -1);\n'.format (member['name'], member['value']))
		if 'bitflag' in enum_data:
			fp.write ('set_enum_bf (id, 1);\n')

def write_funcs (data, fp):
	for name, func_data in data['functions'].items():
		if not 'address' in func_data:
			continue
		write_name_cleanup (fp, name)
		fp.write ('set_name({}, "{}");\n'.format (func_data['address'], name))
		fp.write ('set_func_cmt({}, {}, 0);\n'.format (func_data['address'], stringify (func_data['explanation'])))
		fp.write ('apply_type ({}, "{}", TINFO_DEFINITE);\n'.format (func_data['address'], func_data['text']))

def write_vars (data, fp):
	for name, var_data in data['vars'].items():
		if not 'address' in var_data:
			continue
		write_name_cleanup (fp, name)
		fp.write ('set_name({}, "{}");\n'.format (var_data['address'], name))
		fp.write ('set_cmt({}, {}, 0);\n'.format (var_data['address'], stringify (var_data['explanation'])))
		fp.write ('apply_type ({}, "{}", TINFO_DEFINITE);\n'.format (var_data['address'], var_data['text']))

def write_idc (data, target_filename, src_path):
	fp = open (target_filename, 'w')
	write_header (fp)
	write_enums (data, fp)
	write_structs (data, fp)
	write_funcs(data, fp)
	write_vars(data, fp)
	fp.write('}\n')

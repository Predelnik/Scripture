import re

def write_name_cleanup (fp, name): # cleanup all possible name usages
	# used for linear address (variable/func)
	# TODO: make it function in ids instead of generating ton of code
	fp.write ('addr = get_name_ea_simple ("{}");\n'.format (name))
	fp.write ('if (addr != BADADDR) set_name (addr, "");\n')
	# used for custom data type (local types)
	fp.write ('id = find_custom_data_type("{}");\n'.format (name))
	fp.write ('if (id != -1) set_local_type (-1, "", 0);\n'.format (name))
	# used for struct name
	fp.write ('id = get_struc_id ("{}");\n'.format (name))
	fp.write ('if (id != -1) del_struc(id);\n')
	# used for enum name
	fp.write ('id = get_enum ("{}");\n'.format (name))
	fp.write ('if (id != -1) del_enum(id);\n')

# data is dict specified by extract.py (unstable)
def write_header (fp):
	fp.write ('// Generated by Scripture (https://github.com/predelnik/scripture)\n')
	fp.write ("// Warning: script will aggressively change name of the functions and redefine structs if there's name collision. Use with care.\n")
	fp.write ('\n')
	fp.write ('#include <idc.idc>\n')
	fp.write ('static main() {\n')
	fp.write ('auto id = -1;\n')
	fp.write ('auto addr = -1;\n')
	for bits in ['8', '16', '32']:
		for prefix in [('u', 'unsigned '), ('', '')]:
			for body in ['int', 'bool']:
				if body == 'bool' and prefix[0] == 'u':
					continue
				source_type = '{}{}{}_t'.format (prefix[0], body, bits)
				dest_type = '{} __int{}'.format (prefix[1], bits)
				write_name_cleanup (fp, source_type)
				fp.write ('set_local_type (-1, "typedef {} {}", 0);\n'.format (dest_type, source_type))

def member_flags_id(data, member):
	type = member['type']
	size = int (member['size'])
	if re.match (r'([a-zA-z]*)\s*\(\*\)\((?:([a-zA-z\*]*),\s*)*([a-zA-z\*]*)?\)', type):
		return 'FF_0OFF | FF_DWORD', -1
	m = re.match (r'([a-zA-z0-9_\*]*)\s*(?:\[.*\])*', type)
	if not m:
		return
	type = m.group(1).strip ()
	if type.endswith ('*'):
		return 'FF_OFFSET', 'get_struc_id ("{}")'.format (type[:-1])
	if type in data['structs']:
		return 'FF_STRUCT', 'get_struc_id ("{}")'.format (type)
	if type in data['enums']:
		flag = 'FF_DWORD'
		if size == 2:
			flag = 'FF_WORD'
		elif size == 1:
			flag = 'FF_BYTE'
		return 'FF_0ENUM | {}'.format (flag), 'get_enum ("{}")'.format (type)

	if type in ['int8_t', 'uint8_t', 'bool8_t', 'BYTE', 'char', 'unsigned char']:
		return 'FF_BYTE', -1
	if type in ['int16_t', 'uint16_t', 'bool16_t', 'WORD']:
		return 'FF_WORD', -1
	if type in ['int', 'int32_t', 'uint32_t', 'bool32_t', 'DWORD', 'uint', 'bool']:
		return 'FF_DWORD', -1
	return 'FF_0OFF | FF_DWORD', -1

def write_struct (data, name, struct_data, fp):
	fp.write ('{\n')
	write_name_cleanup (fp, name)
	if not 'offset' in struct_data['members'][0]:
		fp.write ('parse_decls ("{}", 0);\n'.format (struct_data['text'].replace ('\n', '\\n').replace ('\r', '\\r')))
	else:
		fp.write ('id = add_struc(-1, "{}", 0);\n'.format (name))
		for member in struct_data['members']:
			flags, id = member_flags_id (data, member)
			fp.write ('add_struc_member (id, "{}", 0x{}, FF_DATA | {}, {}, {});\n'.format (member['name'], member['offset'], flags, id, member['size']))
	fp.write ('import_type(-1, "{}");'.format (name))
	fp.write ('}\n')

def write_structs (data, fp):
	for file_name in ['sha1.h', 'windows.h', 'structs.h']: # it's hard to determine correct order here in general case
		for name, struct_data in sorted(list (data['structs'].items()), key=lambda t: t[1]['line']):
			if struct_data['full_file_name'] != file_name:
				continue
			write_struct (data, name, struct_data, fp)

def write_enums (data, fp):
	for name, enum_data in sorted(list (data['enums'].items()), key=lambda t: t[1]['line']):
		# Removing previously defined struct to avoid collision
		write_name_cleanup (fp, name)
		# it's yet unclear how to make enum signed, but looks like in IDA 7.0 it doesn't affect anything anyway
		fp.write ('id = add_enum (-1, "{}", {});\n'.format (name, 'FF_0NUMH' if 'bitflag' in enum_data else 'FF_0NUMD'))
		for member in enum_data['members']:
			fp.write ('add_enum_member (id, "{}", {}, -1);\n'.format (member['name'], member['value']))
		if 'bitflag' in enum_data:
			fp.write ('set_enum_bf (id, 1);\n')

def write_funcs (data, fp):
	for name, func_data in data['functions'].items():
		if not 'address' in func_data:
			continue
		write_name_cleanup (fp, name)
		fp.write ('set_name({}, "{}");\n'.format (func_data['address'], name))
		fp.write ('apply_type ({}, "{}", TINFO_DEFINITE);\n'.format (func_data['address'], func_data['text']))

def write_vars (data, fp):
	for name, var_data in data['vars'].items():
		if not 'address' in var_data:
			continue
		write_name_cleanup (fp, name)
		fp.write ('set_name({}, "{}");\n'.format (var_data['address'], name))
		fp.write ('apply_type ({}, "{}", TINFO_DEFINITE);\n'.format (var_data['address'], var_data['text']))

def write_idc (data, target_filename, src_path):
	fp = open (target_filename, 'w')
	write_header (fp)
	write_enums (data, fp)
	write_structs (data, fp)
	write_funcs(data, fp)
	write_vars(data, fp)
	fp.write('}\n')
